function p_optimized = resoud_id2()
    % ========================================
    % üîπ R√©solution d‚Äôun probl√®me d‚Äôidentification
    % üîπ Estimation de 10 param√®tres via moindres carr√©s it√©ratifs
    % ========================================
    % Charger les donn√©es
    load("base.mat"); % 'data' doit contenir .theta et .cartesien

    % Param√®tres initiaux
    np = 8;                         % nombre de param√®tres √† estimer
    p_hat = [0.2 0.1 0.4 0.5 -0.1 0.7 0.9 0.7 0.4 0.4]            % estimation initiale al√©atoire
    k_max = 20;                      % nombre max d‚Äôit√©rations

    % Historique
    P_history = zeros(k_max, np);
    E_history = zeros(k_max, 1);

    % Boucle principale d‚Äôestimation
    for k = 1:k_max
        err_all = [];
        J_all = [];

        % Parcourir chaque exp√©rience
        for i = 1:length(data)
            th = data(i).theta';        % angles (vecteur)
            X  = data(i).cartesien';    % mesures (vecteur)

            % Calcul du mod√®le et du jacobien sur tout le vecteur
            X_model = mod_geom(th, p_hat);
            err = X-X_model;               % vecteur d‚Äôerreur
            J = jacobien(th, p_hat);               % matrice N√ónp

            % Accumulation des r√©sultats
            err_all = [err_all; err]
            J_all = [J_all; J];
        end
        
        % Mise √† jour du vecteur de param√®tres
        Dp = pinv(J_all) * err_all;                % estimation incr√©mentale
        p_hat = p_hat + Dp';                       % mise √† jour des 10 param√®tres

        % Historique
        P_history(k, :) = p_hat;
        E_history(k) = mean(err_all.^2);

    end
    rank(J_all)
    % R√©sultat final
    p_optimized = p_hat;

    % ========================================
    % üîπ Visualisation du co√ªt J(p1) et de l‚Äô√©volution de p1
    % ========================================

    figure;
    PHAT = 0:0.01:1;          % valeurs test pour p1
    Jcost = zeros(size(PHAT));

    % On fixe les autres param√®tres √† leur valeur finale
    th = data(1).theta';
    X = data(1).cartesien';

    for k = 1:length(PHAT)
        p_test = p_optimized;
        p_test(1) = PHAT(k);                  % on fait varier le 1er param√®tre
        X_model = mod_geom(th, p_test);
        ERROR = X - X_model;
        Jcost(k) = mean(ERROR.^2);
    end

    % === Trac√© principal ===
    plot(PHAT, Jcost, 'b', 'LineWidth', 2);
    hold on;
    grid on;


